<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ProcTHOR 3D Visualization</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        
        button {
            margin: 5px;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>ProcTHOR 3D Visualization</h2>
        <p>Use mouse to rotate, scroll to zoom, right-click to pan.</p>
        <div id="stats"></div>
    </div>
    
    <div id="loading">Loading ProcTHOR data...</div>
    
    <div id="controls">
        <button id="toggleWalls">Toggle Walls</button>
        <button id="toggleDoors">Toggle Doors</button>
        <button id="toggleFurniture">Toggle Furniture</button>
        <button id="toggleGrid">Toggle Grid</button>
        <button id="resetCamera">Reset Camera</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Import OrbitControls correctly
        const OrbitControls = function(object, domElement) {
            this.object = object;
            this.domElement = domElement !== undefined ? domElement : document;
            
            // API
            this.enabled = true;
            this.target = new THREE.Vector3();
            
            this.minDistance = 0;
            this.maxDistance = Infinity;
            
            this.minPolarAngle = 0;
            this.maxPolarAngle = Math.PI;
            
            this.minAzimuthAngle = -Infinity;
            this.maxAzimuthAngle = Infinity;
            
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            
            this.enableZoom = true;
            this.zoomSpeed = 1.0;
            
            this.enableRotate = true;
            this.rotateSpeed = 1.0;
            
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = true;
            this.keyPanSpeed = 7.0;
            
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0;
            
            this.enableKeys = true;
            this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
            
            // internals
            this.update = function() {
                const offset = new THREE.Vector3();
                offset.copy(object.position).sub(this.target);
                
                // rotate offset to target
                const spherical = new THREE.Spherical().setFromVector3(offset);
                
                // apply rotation
                object.position.copy(this.target).add(offset);
                
                // look at target
                object.lookAt(this.target);
                
                return true;
            };
        };
        
        let scene, camera, renderer, controls;
        let walls = [], doors = [], furniture = [];
        let gridHelper;
        
        // Sample ProcTHOR data in case fetch fails
        const sampleData = {
            "walls": [
                {"polygon": [{"x": -5, "z": -5}, {"x": 5, "z": -5}, {"x": 5, "z": 5}, {"x": -5, "z": 5}], "height": 3},
                {"polygon": [{"x": -3, "z": -3}, {"x": -1, "z": -3}, {"x": -1, "z": -1}, {"x": -3, "z": -1}], "height": 3}
            ],
            "doors": [
                {"assetPosition": {"x": 0, "y": 0, "z": -5}, "rotation": 0, "width": 1, "height": 2},
                {"assetPosition": {"x": -3, "y": 0, "z": 0}, "rotation": 90, "width": 1, "height": 2}
            ],
            "furniture": [
                {"assetPosition": {"x": 2, "y": 0, "z": 2}, "assetType": "table", "rotation": 0},
                {"assetPosition": {"x": -2, "y": 0, "z": 3}, "assetType": "chair", "rotation": 45}
            ]
        };

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 20);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Grid helper
            gridHelper = new THREE.GridHelper(50, 50);
            scene.add(gridHelper);
            
            // Axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            
            // Add ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Try to load house data or use sample data
            loadHouseData();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Button event listeners
            document.getElementById('toggleWalls').addEventListener('click', () => toggleGroup(walls));
            document.getElementById('toggleDoors').addEventListener('click', () => toggleGroup(doors));
            document.getElementById('toggleFurniture').addEventListener('click', () => toggleGroup(furniture));
            document.getElementById('toggleGrid').addEventListener('click', () => {
                gridHelper.visible = !gridHelper.visible;
            });
            document.getElementById('resetCamera').addEventListener('click', resetCamera);
            
            // Start animation loop
            animate();
        }
        
        function loadHouseData() {
            // Try to load JSON file, if it fails use sample data
            fetch('house.json')
                .then(response => {
                    if (!response.ok) throw new Error("Failed to load JSON");
                    return response.json();
                })
                .then(data => {
                    console.log("Loaded house.json:", data);
                    generateScene(data);
                })
                .catch(error => {
                    console.warn("Error loading JSON:", error);
                    console.log("Using sample data instead");
                    generateScene(sampleData);
                })
                .finally(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('stats').innerHTML = 
                        `Walls: ${walls.length}, Doors: ${doors.length}, Furniture: ${furniture.length}`;
                });
        }
        
        function generateScene(data) {
            // Clear any previous objects
            clearObjects();
            
            // Create walls (as 3D objects, not just lines)
            if (data.walls) {
                data.walls.forEach(wall => {
                    if (!wall.polygon || wall.polygon.length < 3) return;
                    
                    createWall(wall);
                });
            }
            
            // Create doors
            if (data.doors) {
                data.doors.forEach(door => {
                    if (!door.assetPosition) return;
                    createDoor(door);
                });
            }
            
            // Create furniture
            if (data.furniture) {
                data.furniture.forEach(item => {
                    if (!item.assetPosition) return;
                    createFurniture(item);
                });
            }
        }
        
        function createWall(wall) {
            // Get wall height (default to 3 if not specified)
            const height = wall.height || 3;
            
            // Create shape from polygon points
            const shape = new THREE.Shape();
            const points = wall.polygon;
            
            if (points.length < 3) return;
            
            // Start at first point
            shape.moveTo(points[0].x, points[0].z);
            
            // Connect remaining points
            for (let i = 1; i < points.length; i++) {
                shape.lineTo(points[i].x, points[i].z);
            }
            
            // Close shape
            shape.lineTo(points[0].x, points[0].z);
            
            // Create extrusion settings
            const extrudeSettings = {
                steps: 1,
                depth: height,
                bevelEnabled: false
            };
            
            // Create geometry and material
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.rotateX(Math.PI / 2); // Rotate to correct orientation
            
            const material = new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Create mesh
            const wallMesh = new THREE.Mesh(geometry, material);
            wallMesh.castShadow = true;
            wallMesh.receiveShadow = true;
            
            // Add to scene and walls array
            scene.add(wallMesh);
            walls.push(wallMesh);
            
            // Add wireframe outline
            const wireframe = new THREE.LineSegments(
                new THREE.WireframeGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
            );
            wallMesh.add(wireframe);
        }
        
        function createDoor(door) {
            const width = door.width || 1;
            const height = door.height || 2;
            const depth = 0.1;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,  // Brown color for doors
                roughness: 0.8,
                metalness: 0.2
            });
            
            const doorMesh = new THREE.Mesh(geometry, material);
            
            // Position door
            const pos = door.assetPosition;
            doorMesh.position.set(pos.x, pos.y + height / 2, pos.z); // Add half height to center vertically
            
            // Apply rotation (convert degrees to radians if needed)
            if (door.rotation !== undefined) {
                doorMesh.rotation.y = door.rotation * (Math.PI / 180);
            }
            
            doorMesh.castShadow = true;
            doorMesh.receiveShadow = true;
            
            // Add to scene and doors array
            scene.add(doorMesh);
            doors.push(doorMesh);
        }
        
        function createFurniture(item) {
            // Create simple furniture based on type
            let geometry, material, color;
            
            switch (item.assetType?.toLowerCase()) {
                case 'table':
                    geometry = new THREE.BoxGeometry(1.5, 0.8, 1.5);
                    color = 0x964B00; // Brown
                    break;
                case 'chair':
                    geometry = new THREE.BoxGeometry(0.6, 1, 0.6);
                    color = 0x964B00; // Brown
                    break;
                case 'bed':
                    geometry = new THREE.BoxGeometry(2, 0.5, 1.5);
                    color = 0x4169E1; // Royal Blue
                    break;
                case 'sofa':
                    geometry = new THREE.BoxGeometry(2, 0.8, 0.8);
                    color = 0x808080; // Gray
                    break;
                default:
                    // Default cube for unknown furniture
                    geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    color = 0x808080; // Gray
            }
            
            material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const furnitureMesh = new THREE.Mesh(geometry, material);
            
            // Position furniture
            const pos = item.assetPosition;
            furnitureMesh.position.set(pos.x, pos.y + geometry.parameters.height / 2, pos.z);
            
            // Apply rotation (convert degrees to radians if needed)
            if (item.rotation !== undefined) {
                furnitureMesh.rotation.y = item.rotation * (Math.PI / 180);
            }
            
            furnitureMesh.castShadow = true;
            furnitureMesh.receiveShadow = true;
            
            // Add to scene and furniture array
            scene.add(furnitureMesh);
            furniture.push(furnitureMesh);
        }
        
        function clearObjects() {
            // Remove all walls, doors, and furniture
            [...walls, ...doors, ...furniture].forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            
            walls = [];
            doors = [];
            furniture = [];
        }
        
        function toggleGroup(group) {
            group.forEach(obj => {
                obj.visible = !obj.visible;
            });
        }
        
        function resetCamera() {
            camera.position.set(0, 15, 20);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        init();
    </script>
</body>
</html>